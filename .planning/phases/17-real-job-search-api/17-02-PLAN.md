---
phase: 17-real-job-search-api
plan: 02
type: execute
wave: 2
depends_on: ["17-01"]
files_modified:
  - packages/frontend/src/routes/api/prospection.ts
  - packages/frontend/src/lib/jobScoring.ts
autonomous: true

must_haves:
  truths:
    - "Prospection API returns real Google Places results"
    - "Job cards have real business names and addresses"
    - "Jobs are scored using skill arbitrage algorithm"
  artifacts:
    - path: "packages/frontend/src/routes/api/prospection.ts"
      provides: "Real Places API integration"
      contains: "findNearbyPlaces"
    - path: "packages/frontend/src/lib/jobScoring.ts"
      provides: "Job scoring algorithm for frontend"
      exports: ["scoreJob", "scoreJobsForProfile"]
  key_links:
    - from: "packages/frontend/src/routes/api/prospection.ts"
      to: "@stride/mcp-server/services"
      via: "dynamic import"
      pattern: "import.*@stride/mcp-server/services"
    - from: "packages/frontend/src/lib/jobScoring.ts"
      to: "skill-arbitrage algorithm"
      via: "scoring formula adaptation"
      pattern: "distance.*profile.*effort"
---

<objective>
Replace mock job data with real Google Places API calls and create job scoring utility.

Purpose: JOBS-01 (real results), JOBS-04 (skill matching), JOBS-05 (scoring algorithm)
Output: Real job search API and frontend scoring utility
</objective>

<execution_context>
@/home/nico/.claude/get-shit-done/workflows/execute-plan.md
@/home/nico/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/17-real-job-search-api/17-01-SUMMARY.md

@packages/frontend/src/routes/api/prospection.ts
@packages/frontend/src/routes/api/agent.ts (for import pattern)
@packages/mcp-server/src/algorithms/skill-arbitrage.ts (for scoring algorithm)
@packages/frontend/src/config/prospectionCategories.ts
@packages/frontend/src/lib/prospectionTypes.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Replace mocks with real Google Places API</name>
  <files>packages/frontend/src/routes/api/prospection.ts</files>
  <action>
Replace the generateMockCards() function with real Google Places API calls using the direct MCP import pattern.

1. Remove the entire generateMockCards() function (lines 100-174)

2. Add the Google Maps service import and helper at the top of the file (after existing imports):
   ```typescript
   // Google Maps service (lazy loaded to avoid bundling issues)
   let googleMapsService: typeof import('@stride/mcp-server/services') | null = null;

   async function getGoogleMaps() {
     if (!googleMapsService) {
       googleMapsService = await import('@stride/mcp-server/services');
       await googleMapsService.initGoogleMaps();
     }
     return googleMapsService;
   }
   ```

3. Create a new function to search using real Places API:
   ```typescript
   async function searchRealPlaces(
     category: ProspectionCategory,
     latitude?: number,
     longitude?: number,
     city?: string,
     radius: number = 5000
   ): Promise<ProspectionCard[]> {
     // If no coordinates, return empty (location required for Places API)
     if (!latitude || !longitude) {
       logger.warn('No coordinates provided for Places search', { city });
       return [];
     }

     const maps = await getGoogleMaps();

     // Search for each Google Place type in the category
     const allPlaces: ProspectionCard[] = [];

     for (const placeType of category.googlePlaceTypes) {
       try {
         const places = await maps.findNearbyPlaces(
           { lat: latitude, lng: longitude },
           placeType as import('@stride/mcp-server/services').PlaceType,
           {
             radius,
             keyword: category.queryTemplate,
             maxResults: 10,
             includePhotos: false // Cost control
           }
         );

         // Convert Place to ProspectionCard
         for (const place of places) {
           const distance = maps.calculateDistance(
             { lat: latitude, lng: longitude },
             place.location
           );
           const commuteMinutes = Math.round(distance / 80); // ~80m/min walking speed

           // Random hourly rate within category range
           const hourlyRate = category.avgHourlyRate.min +
             Math.random() * (category.avgHourlyRate.max - category.avgHourlyRate.min);

           allPlaces.push({
             id: `${category.id}_${place.placeId}`,
             type: 'place',
             title: category.examples[Math.floor(Math.random() * category.examples.length)],
             company: place.name,
             location: place.address,
             lat: place.location.lat,
             lng: place.location.lng,
             commuteMinutes,
             commuteText: `${commuteMinutes} min`,
             salaryText: `${hourlyRate.toFixed(2)}€/h`,
             avgHourlyRate: Math.round(hourlyRate * 100) / 100,
             effortLevel: category.effortLevel,
             source: 'Google Maps',
             url: `https://www.google.com/maps/place/?q=place_id:${place.placeId}`,
             categoryId: category.id,
             rating: place.rating,
             openNow: place.openNow,
           });
         }
       } catch (error) {
         logger.error('Places search error', { placeType, error });
       }
     }

     // If category has no googlePlaceTypes, return platform-based suggestions
     if (category.googlePlaceTypes.length === 0) {
       return generatePlatformCards(category, city);
     }

     return allPlaces;
   }
   ```

4. Add fallback for categories without Google Place types:
   ```typescript
   function generatePlatformCards(category: ProspectionCategory, city?: string): ProspectionCard[] {
     const cityName = city || 'your city';
     return category.platforms.slice(0, 5).map((platform, i) => ({
       id: `${category.id}_platform_${i}_${Date.now()}`,
       type: 'job',
       title: category.examples[i % category.examples.length],
       company: platform,
       location: cityName,
       salaryText: `${category.avgHourlyRate.min}-${category.avgHourlyRate.max}€/h`,
       avgHourlyRate: (category.avgHourlyRate.min + category.avgHourlyRate.max) / 2,
       effortLevel: category.effortLevel,
       source: platform,
       url: `https://${platform.toLowerCase().replace(/\s/g, '')}.com`,
       categoryId: category.id,
     }));
   }
   ```

5. Update the POST handler to use searchRealPlaces instead of generateMockCards:
   Change line 76:
   ```typescript
   // OLD: const cards: ProspectionCard[] = generateMockCards(category, city, latitude, longitude);
   // NEW:
   const cards = await searchRealPlaces(category, latitude, longitude, city, radius);
   ```

6. Add type import at top:
   ```typescript
   import type { ProspectionCategory, ProspectionCard } from '~/lib/prospectionTypes';
   ```
   (This may already exist - verify and keep if so)
  </action>
  <verify>
1. `pnpm typecheck` passes
2. Test API manually: `curl -X POST http://localhost:3006/api/prospection -H "Content-Type: application/json" -d '{"action":"search","categoryId":"service","latitude":48.8566,"longitude":2.3522}'`
3. Response should contain real place names (not mock data like "Le Petit Bistrot")
  </verify>
  <done>
Prospection API returns real Google Places results for categories with googlePlaceTypes, falls back to platform suggestions for categories without place types.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create job scoring utility</name>
  <files>packages/frontend/src/lib/jobScoring.ts</files>
  <action>
Create a frontend utility to score jobs based on distance, profile match, and effort (adapted from skill-arbitrage algorithm).

Create new file `packages/frontend/src/lib/jobScoring.ts`:

```typescript
/**
 * Job Scoring Utility
 *
 * Scores job opportunities based on:
 * - Distance (30%): Closer is better
 * - Profile match (25%): Matches user skills and preferences
 * - Effort level (25%): Lower effort is better for sustainability
 * - Rate (20%): Higher pay is better
 *
 * Returns score 1-5 (star rating format)
 *
 * Adapted from skill-arbitrage algorithm in mcp-server.
 */

import type { ProspectionCard } from './prospectionTypes';

export interface JobScoreBreakdown {
  distance: number;  // 0-1 normalized
  profile: number;   // 0-1 normalized
  effort: number;    // 0-1 normalized
  rate: number;      // 0-1 normalized
}

export interface ScoredJob extends ProspectionCard {
  score: number;           // 1-5 star rating
  scoreBreakdown: JobScoreBreakdown;
}

export interface UserProfile {
  skills?: string[];
  maxWorkHoursWeekly?: number;
  minHourlyRate?: number;
}

// Scoring weights (must sum to 1.0)
const WEIGHTS = {
  distance: 0.30,
  profile: 0.25,
  effort: 0.25,
  rate: 0.20,
};

// Normalization constants
const MAX_COMMUTE_MINUTES = 45;  // 45+ min = score 0
const MAX_HOURLY_RATE = 25;      // 25€/h = normalized to 1.0
const MAX_EFFORT = 5;

/**
 * Calculate job score based on multiple factors
 * Returns score 1-5 (star rating)
 */
export function scoreJob(
  job: ProspectionCard,
  profile?: UserProfile
): ScoredJob {
  // Distance score: closer is better (invert: 45min = 0, 0min = 1)
  const commuteMinutes = job.commuteMinutes ?? 30;
  const distanceNorm = Math.max(0, 1 - commuteMinutes / MAX_COMMUTE_MINUTES);

  // Profile match score: check if job matches user skills/preferences
  const profileNorm = calculateProfileMatch(job, profile);

  // Effort score: lower effort is better (invert)
  const effortLevel = job.effortLevel ?? 3;
  const effortNorm = 1 - (effortLevel - 1) / (MAX_EFFORT - 1);

  // Rate score: higher is better
  const hourlyRate = job.avgHourlyRate ?? 11;
  const rateNorm = Math.min(hourlyRate / MAX_HOURLY_RATE, 1);

  // Weighted sum
  const rawScore =
    WEIGHTS.distance * distanceNorm +
    WEIGHTS.profile * profileNorm +
    WEIGHTS.effort * effortNorm +
    WEIGHTS.rate * rateNorm;

  // Convert to 1-5 star scale
  const score = Math.round((1 + rawScore * 4) * 10) / 10;

  return {
    ...job,
    score: Math.min(5, Math.max(1, score)),
    scoreBreakdown: {
      distance: distanceNorm,
      profile: profileNorm,
      effort: effortNorm,
      rate: rateNorm,
    },
  };
}

/**
 * Calculate profile match score
 * Returns 0-1 based on how well the job matches user profile
 */
function calculateProfileMatch(
  job: ProspectionCard,
  profile?: UserProfile
): number {
  if (!profile) return 0.5; // Neutral if no profile

  let score = 0.5; // Base score

  // Skill match bonus
  if (profile.skills && profile.skills.length > 0) {
    const jobCategory = job.categoryId;
    const skillMatches = matchSkillsToCategory(profile.skills, jobCategory);
    score += skillMatches * 0.3; // Up to +0.3 for skill match
  }

  // Rate preference match
  if (profile.minHourlyRate && job.avgHourlyRate) {
    if (job.avgHourlyRate >= profile.minHourlyRate) {
      score += 0.2; // Meets minimum rate requirement
    }
  }

  return Math.min(1, Math.max(0, score));
}

/**
 * Match user skills to job category
 * Returns 0-1 based on skill relevance
 */
function matchSkillsToCategory(skills: string[], categoryId: string): number {
  // Skill-to-category mapping
  const categorySkillMap: Record<string, string[]> = {
    service: ['communication', 'customer service', 'hospitality', 'food service', 'teamwork'],
    retail: ['sales', 'customer service', 'inventory', 'communication', 'cash handling'],
    cleaning: ['attention to detail', 'time management', 'physical fitness'],
    handyman: ['construction', 'repair', 'tools', 'physical fitness', 'problem solving'],
    childcare: ['childcare', 'patience', 'communication', 'first aid', 'creativity'],
    tutoring: ['teaching', 'math', 'science', 'languages', 'patience', 'communication'],
    events: ['communication', 'customer service', 'appearance', 'stamina'],
    interim: ['flexibility', 'adaptability', 'physical fitness', 'teamwork'],
    digital: ['computer', 'typing', 'social media', 'writing', 'design', 'programming'],
    campus: ['organization', 'computer', 'customer service', 'time management'],
  };

  const relevantSkills = categorySkillMap[categoryId] || [];
  if (relevantSkills.length === 0) return 0;

  const normalizedSkills = skills.map(s => s.toLowerCase());
  const matches = relevantSkills.filter(rs =>
    normalizedSkills.some(us => us.includes(rs) || rs.includes(us))
  );

  return matches.length / relevantSkills.length;
}

/**
 * Score multiple jobs and sort by score
 */
export function scoreJobsForProfile(
  jobs: ProspectionCard[],
  profile?: UserProfile
): ScoredJob[] {
  return jobs
    .map(job => scoreJob(job, profile))
    .sort((a, b) => b.score - a.score);
}

/**
 * Get star rating display (e.g., "4.2")
 */
export function formatStarRating(score: number): string {
  return score.toFixed(1);
}

/**
 * Check if job qualifies as "Top Pick" (score >= 4.5)
 */
export function isTopPick(score: number): boolean {
  return score >= 4.5;
}
```
  </action>
  <verify>
1. `pnpm typecheck` passes
2. File exists with expected exports: `grep -E "export.*scoreJob|export.*scoreJobsForProfile" packages/frontend/src/lib/jobScoring.ts`
  </verify>
  <done>
jobScoring.ts created with scoreJob(), scoreJobsForProfile(), formatStarRating(), and isTopPick() functions for frontend use.
  </done>
</task>

</tasks>

<verification>
1. `pnpm typecheck` passes for entire project
2. Prospection API returns real Google Places data (test with Paris coordinates)
3. jobScoring.ts exports all required functions
4. Types are consistent between prospectionTypes.ts and jobScoring.ts
</verification>

<success_criteria>
- Prospection POST /api/prospection returns real place names and addresses
- Jobs have real Google ratings
- Jobs have calculated commute times based on actual distance
- jobScoring.ts can score jobs and identify top picks
- Categories without googlePlaceTypes gracefully fall back to platform cards
</success_criteria>

<output>
After completion, create `.planning/phases/17-real-job-search-api/17-02-SUMMARY.md`
</output>
