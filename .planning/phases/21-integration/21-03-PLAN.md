---
phase: 21-integration
plan: 03
type: execute
wave: 2
depends_on: ["21-01"]
files_modified:
  - packages/frontend/src/components/WeeklyProgressCards.tsx
  - packages/frontend/src/components/EarningsChart.tsx
autonomous: true

must_haves:
  truths:
    - "WeeklyProgressCards receives data via props instead of fetching internally"
    - "EarningsChart receives data via props instead of computing independently"
    - "Components are pure display components (no internal data fetching)"
    - "Retroplan fetching removed from WeeklyProgressCards"
  artifacts:
    - path: "packages/frontend/src/components/WeeklyProgressCards.tsx"
      provides: "Pure display component for weekly progress"
    - path: "packages/frontend/src/components/EarningsChart.tsx"
      provides: "Pure display component for earnings chart"
  key_links:
    - from: "packages/frontend/src/components/WeeklyProgressCards.tsx"
      to: "props.retroplan"
      via: "prop drilling"
      pattern: "props\\.retroplan"
    - from: "packages/frontend/src/components/EarningsChart.tsx"
      to: "props"
      via: "prop drilling"
      pattern: "props\\."
---

<objective>
Convert WeeklyProgressCards and EarningsChart to pure display components that receive all data via props.

Purpose: Remove internal data fetching from child components so GoalsTab (via useGoalData hook) is the single source of truth. This ensures consistency across all displays.

Output: Pure display components that render data passed via props without any internal API calls.
</objective>

<execution_context>
@/home/nico/.claude/get-shit-done/workflows/execute-plan.md
@/home/nico/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/21-integration/21-01-SUMMARY.md
@packages/frontend/src/hooks/useGoalData.ts
@packages/frontend/src/components/WeeklyProgressCards.tsx
@packages/frontend/src/components/EarningsChart.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Convert WeeklyProgressCards to pure display component</name>
  <files>packages/frontend/src/components/WeeklyProgressCards.tsx</files>
  <action>
Refactor WeeklyProgressCards to receive retroplan data via props instead of fetching internally.

**Step 1: Add retroplan to props interface**

Update `WeeklyProgressCardsProps`:
```typescript
interface WeeklyProgressCardsProps {
  goal: Goal;
  currency?: Currency;
  weeklyEarnings?: Array<{ week: number; earned: number }>;
  hourlyRate?: number;
  simulatedDate?: Date;
  incomeDay?: number;
  monthlyMargin?: number;
  savingsAdjustments?: Record<number, { amount: number; note?: string; adjustedAt: string }>;
  onAdjustSavings?: (weekNumber: number, currentAmount: number) => void;
  userId?: string;

  // NEW: Receive retroplan data from parent instead of fetching
  retroplan?: {
    milestones: RetroplanMilestone[];
    feasibilityScore?: number;
  } | null;
}
```

**Step 2: Remove internal retroplan fetch**

DELETE lines 134-166 (the createEffect that fetches retroplan):
```typescript
// DELETE THIS ENTIRE BLOCK:
createEffect(() => {
  const goal = props.goal;
  if (goal.status === 'active' && goal.deadline && goal.amount && props.userId) {
    fetch('/api/retroplan', { ... })
      .then(...)
      .catch(() => {});
  }
});
```

**Step 3: Replace signal with prop**

Change `const [retroplan, setRetroplan] = createSignal<...>(null);`
TO: Use props.retroplan directly

Update all references from `retroplan()` to `props.retroplan`:
- Line 169: `const plan = retroplan();` -> `const plan = props.retroplan;`
- Line 181: `const plan = retroplan();` -> `const plan = props.retroplan;`
- Line 201: `const plan = retroplan();` -> `const plan = props.retroplan;`

**Step 4: Simplify weekInfo memo**

The weekInfo memo (lines 168-178) depends on retroplan. Update it:
```typescript
const weekInfo = createMemo(() => {
  const plan = props.retroplan;
  if (!plan?.milestones?.length) return null;

  const startDate = plan.milestones[0]?.capacity.weekStartDate;
  if (!startDate) return null;

  return getCurrentWeekInfo(startDate, plan.milestones.length, props.simulatedDate);
});
```

**Step 5: Remove unused imports**

After removing the fetch:
- Remove `createSignal` import if no longer used
- Keep `createMemo`, `createEffect` if still used for other purposes

**Benefits:**
- ARCH-04: WeeklyProgressCards becomes pure display component
- No more duplicate retroplan fetching
- Consistent data from parent
  </action>
  <verify>
1. TypeScript compiles: `cd packages/frontend && pnpm typecheck`
2. No fetch in component: `grep -n "fetch.*retroplan" packages/frontend/src/components/WeeklyProgressCards.tsx` returns empty
  </verify>
  <done>
WeeklyProgressCards receives retroplan via props, no internal API calls.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update GoalsTab to pass retroplan to WeeklyProgressCards</name>
  <files>packages/frontend/src/components/tabs/GoalsTab.tsx</files>
  <action>
Update the WeeklyProgressCards usage in GoalsTab to pass the retroplan prop.

Find the WeeklyProgressCards usage (around line 1255) and add the retroplan prop:

```typescript
<WeeklyProgressCards
  goal={goals().find((g) => g.id === goalId)!}
  currency={currency()}
  hourlyRate={profile()?.minHourlyRate}
  weeklyEarnings={transformEarningsToWeekly(goalData.earnings())}
  simulatedDate={props.simulatedDate}
  incomeDay={profile()?.incomeDay}
  monthlyMargin={monthlyMargin()}
  savingsAdjustments={followupData()?.savingsAdjustments}
  onAdjustSavings={handleOpenSavingsAdjust}
  userId={profileId() || undefined}
  retroplan={goalData.retroplan() ? {
    milestones: goalData.retroplan()!.milestones,
    feasibilityScore: goalData.retroplan()!.feasibilityScore,
  } : null}
/>
```

This ensures:
- Single retroplan fetch (in useGoalData hook)
- Consistent data passed to WeeklyProgressCards
- No duplicate API calls
  </action>
  <verify>
`grep -n "retroplan=" packages/frontend/src/components/tabs/GoalsTab.tsx` shows retroplan prop being passed
  </verify>
  <done>
GoalsTab passes retroplan prop to WeeklyProgressCards.
  </done>
</task>

<task type="auto">
  <name>Task 3: Enhance EarningsChart props for capacity-aware data</name>
  <files>packages/frontend/src/components/EarningsChart.tsx</files>
  <action>
Update EarningsChart to receive capacity-aware milestone data via props, preparing it to use capacity-aware pace line (Phase 22 will implement the actual line).

**Step 1: Add milestones to props interface**

Update `EarningsChartProps`:
```typescript
interface EarningsChartProps {
  goal: Goal;
  weeklyEarnings?: WeeklyEarning[];
  currentSaved?: number;
  currency?: Currency;
  compact?: boolean;
  adjustedWeeklyTarget?: number;

  // NEW: Capacity-aware milestones from retroplan
  milestones?: Array<{
    week: number;
    adjustedTarget: number;
    cumulativeTarget: number;
  }>;
}
```

**Step 2: Update generateChartData to use milestones**

The `generateChartData` function (lines 65-124) currently computes linear pace. Update it to optionally use capacity-aware data when milestones are provided:

```typescript
const generateChartData = () => {
  const goal = props.goal;
  const goalAmount = goal.amount;
  const currentSaved = props.currentSaved ?? Math.round((goalAmount * (goal.progress || 0)) / 100);

  // ... existing code for labels, totalWeeks ...

  // If milestones provided, use capacity-aware pace
  if (props.milestones && props.milestones.length > 0) {
    // Use milestone cumulative targets for "Required pace" line
    for (let i = 0; i <= weeksCount; i++) {
      const milestone = props.milestones.find(m => m.week === i) || props.milestones[i - 1];
      if (milestone) {
        requiredPace.push(Math.min(goalAmount, milestone.cumulativeTarget));
      } else {
        // Fallback to linear for weeks beyond milestones
        requiredPace.push(Math.round(currentSaved + weeklyRequired * i));
      }
    }
  } else {
    // Fallback: linear pace (existing behavior)
    for (let i = 0; i <= weeksCount; i++) {
      const requiredCumulative = Math.min(goalAmount, currentSaved + weeklyRequired * i);
      requiredPace.push(Math.round(requiredCumulative));
    }
  }

  // ... rest of existing code ...
};
```

**Step 3: Document the change**

Add a comment explaining the prop:
```typescript
/**
 * Capacity-adjusted weekly milestones from retroplan.
 * When provided, the "Required Pace" line uses capacity-aware targets
 * instead of linear division.
 * @see useGoalData hook for data source
 */
milestones?: Array<{...}>;
```

This prepares EarningsChart for Phase 22's calculation unification without breaking existing behavior.
  </action>
  <verify>
1. TypeScript compiles: `cd packages/frontend && pnpm typecheck`
2. Props updated: `grep -n "milestones" packages/frontend/src/components/EarningsChart.tsx`
  </verify>
  <done>
EarningsChart accepts milestones prop and uses it for capacity-aware pace line when provided.
  </done>
</task>

</tasks>

<verification>
1. `cd packages/frontend && pnpm typecheck` passes
2. `cd packages/frontend && pnpm lint` passes
3. No internal fetch in WeeklyProgressCards: `grep -c "fetch.*retroplan" packages/frontend/src/components/WeeklyProgressCards.tsx` returns 0
4. Manual test: Load /plan?tab=goals with an active goal
   - Weekly Progress Cards still display correctly
   - Earnings Chart still displays correctly
   - Network tab shows only ONE retroplan call (from useGoalData), not two
</verification>

<success_criteria>
1. WeeklyProgressCards no longer fetches retroplan internally
2. WeeklyProgressCards receives retroplan via props
3. GoalsTab passes retroplan prop to WeeklyProgressCards
4. EarningsChart accepts milestones prop for capacity-aware pace
5. All components render correctly
6. Single source of truth: only useGoalData fetches retroplan
</success_criteria>

<output>
After completion, create `.planning/phases/21-integration/21-03-SUMMARY.md`
</output>
