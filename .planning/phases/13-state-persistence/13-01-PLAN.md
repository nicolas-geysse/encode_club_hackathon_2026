---
phase: 13-state-persistence
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/frontend/src/lib/onboardingStateStore.ts
  - packages/frontend/src/entry-client.tsx
autonomous: true

must_haves:
  truths:
    - "After completing onboarding, navigating to /plan and back does NOT restart onboarding"
    - "Navigation menu items remain visible after returning from other pages"
    - "Hard refresh after onboarding shows completed state (not restart)"
  artifacts:
    - path: "packages/frontend/src/lib/onboardingStateStore.ts"
      provides: "Hydration-safe localStorage initialization"
      contains: "initOnboardingState"
    - path: "packages/frontend/src/entry-client.tsx"
      provides: "Client-side initialization call"
      contains: "initOnboardingState"
  key_links:
    - from: "packages/frontend/src/entry-client.tsx"
      to: "packages/frontend/src/lib/onboardingStateStore.ts"
      via: "import and call initOnboardingState"
      pattern: "initOnboardingState"
---

<objective>
Fix onboarding state persistence bug where navigation resets the completed state.

Purpose: The onboardingStateStore currently attempts to read localStorage at module-load time, but this runs on the server during SSR where `window` is undefined. The module is then cached and reused on the client without re-running the initialization. This causes the state to always start as `false` even when localStorage has `onboardingComplete=true`.

Output: Working persistence where onboarding completion state survives:
1. Navigation to /plan and back to /
2. Hard page refresh
3. Multiple browser sessions
</objective>

<execution_context>
@/home/nico/.claude/get-shit-done/workflows/execute-plan.md
@/home/nico/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

Key files to modify:
@packages/frontend/src/lib/onboardingStateStore.ts
@packages/frontend/src/entry-client.tsx

Related consumers (read-only, for understanding):
@packages/frontend/src/components/layout/Sidebar.tsx
@packages/frontend/src/components/layout/BottomNav.tsx
@packages/frontend/src/components/chat/OnboardingChat.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Make onboardingStateStore hydration-safe</name>
  <files>packages/frontend/src/lib/onboardingStateStore.ts</files>
  <action>
  Refactor the localStorage initialization to be hydration-safe:

  1. Remove the module-level `if (typeof window !== 'undefined')` block (lines 14-18)

  2. Add a new exported function `initOnboardingState()` that:
     - Checks `typeof window !== 'undefined'` (client-side guard)
     - Reads `localStorage.getItem('onboardingComplete')`
     - If value is `'true'`, calls `setIsComplete(true)`
     - This function is idempotent (can be called multiple times safely)

  3. Keep the existing exports unchanged:
     - `onboardingIsComplete` (Accessor<boolean>)
     - `setOnboardingComplete` (function)
     - `persistOnboardingComplete` (function)

  The pattern ensures:
  - Server-side: signal starts as `false`, no localStorage access
  - Client-side: `initOnboardingState()` is called early in hydration to sync from localStorage
  - Navigation: signal remains reactive, no re-initialization needed
  </action>
  <verify>
  Run `pnpm typecheck` - should pass with no errors in onboardingStateStore.ts
  Verify `initOnboardingState` is exported: `grep -n "export.*initOnboardingState" packages/frontend/src/lib/onboardingStateStore.ts`
  </verify>
  <done>
  onboardingStateStore.ts exports `initOnboardingState()` function that reads localStorage when called on client.
  Module-level initialization code is removed.
  </done>
</task>

<task type="auto">
  <name>Task 2: Call initOnboardingState in entry-client</name>
  <files>packages/frontend/src/entry-client.tsx</files>
  <action>
  Add the initialization call to entry-client.tsx:

  1. Import `initOnboardingState` from the store:
     ```typescript
     import { initOnboardingState } from '~/lib/onboardingStateStore';
     ```

  2. Call it in the existing IIFE (before mount) or create a new IIFE right after the theme script:
     ```typescript
     // Initialize onboarding state from localStorage (must run before app hydrates)
     initOnboardingState();
     ```

  Place this AFTER the theme script IIFE and BEFORE the `mount()` call.
  This ensures the signal is populated before React hydration begins.

  The pattern matches how the theme is already being initialized synchronously.
  </action>
  <verify>
  Run `pnpm --filter @stride/frontend build` - should build successfully
  Verify the import and call exist: `grep -n "initOnboardingState" packages/frontend/src/entry-client.tsx`
  </verify>
  <done>
  entry-client.tsx imports and calls `initOnboardingState()` before mounting the app.
  Build succeeds without errors.
  </done>
</task>

</tasks>

<verification>
After both tasks:

1. **Build check**: `pnpm --filter @stride/frontend build` passes
2. **Type check**: `pnpm typecheck` passes
3. **Manual verification**:
   - Start dev server: `pnpm dev`
   - Complete onboarding flow (or set `localStorage.setItem('onboardingComplete', 'true')` in devtools)
   - Verify sidebar/bottom nav shows all items
   - Navigate to /plan, then back to / - onboarding should NOT restart
   - Hard refresh the page - state should persist
   - Open a new browser tab to the same URL - state should persist
</verification>

<success_criteria>
- [ ] onboardingStateStore.ts has `initOnboardingState()` exported
- [ ] Module-level localStorage access removed from onboardingStateStore.ts
- [ ] entry-client.tsx calls `initOnboardingState()` before mount
- [ ] Build passes
- [ ] Navigation to /plan and back preserves completed state
- [ ] Hard refresh preserves completed state
</success_criteria>

<output>
After completion, create `.planning/phases/13-state-persistence/13-01-SUMMARY.md`
</output>
