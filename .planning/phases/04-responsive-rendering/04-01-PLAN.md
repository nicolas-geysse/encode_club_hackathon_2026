---
phase: 04-responsive-rendering
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/frontend/src/components/chat/MCPUIRenderer.tsx
autonomous: true

must_haves:
  truths:
    - "On desktop (>768px), chat displays iframe with SwipeTab at /embed/swipe"
    - "On mobile (<=768px), chat displays 'Swipe to plan ! →' navigation button"
    - "Resizing viewport dynamically switches between iframe and button"
    - "Iframe loads with error fallback to button if loading fails"
  artifacts:
    - path: "packages/frontend/src/components/chat/MCPUIRenderer.tsx"
      provides: "SwipeEmbedResource component with responsive rendering"
      contains: "swipe_embed"
  key_links:
    - from: "packages/frontend/src/components/chat/MCPUIRenderer.tsx"
      to: "/embed/swipe"
      via: "iframe src attribute"
      pattern: "embedUrl.*embed/swipe"
    - from: "packages/frontend/src/components/chat/MCPUIRenderer.tsx"
      to: "/plan?tab=swipe"
      via: "navigation button href"
      pattern: "fallbackUrl.*plan.*swipe"
---

<objective>
Add SwipeEmbedResource component to MCPUIRenderer that renders iframe on desktop and navigation button on mobile.

Purpose: Complete the responsive rendering phase so chat can display the Swipe embed component appropriately based on viewport size.
Output: Modified MCPUIRenderer with swipe_embed type handler using viewport detection.
</objective>

<execution_context>
@/home/nico/.claude/get-shit-done/workflows/execute-plan.md
@/home/nico/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-responsive-rendering/04-CONTEXT.md

Key facts:
- MCPUIRenderer uses Switch/Match pattern for type dispatch (lines 77-117)
- swipe_embed type is already defined in ~/types/chat.ts with params: embedUrl, fallbackUrl, height, title
- Chat API creates swipe_embed resource at routes/api/chat.ts:1641-1663
- Embed route at /embed/swipe is ready and chrome-free
- UIResource params include: embedUrl='/embed/swipe', fallbackUrl='/plan?tab=swipe', height=450

@packages/frontend/src/components/chat/MCPUIRenderer.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add SwipeEmbedResource component with responsive rendering</name>
  <files>packages/frontend/src/components/chat/MCPUIRenderer.tsx</files>
  <action>
Add a new SwipeEmbedResource component and Match case to handle 'swipe_embed' type.

1. **Add Match case** in ResourceRenderer Switch (after line 114, before closing `</Switch>`):
```tsx
<Match when={props.resource.type === 'swipe_embed'}>
  <SwipeEmbedResource params={(props.resource as any).params} />
</Match>
```

2. **Create SwipeEmbedResource component** (before the simpleMarkdown function, around line 654):

```tsx
/**
 * Swipe Embed Resource - Responsive iframe/button for Swipe strategies
 * Desktop: renders iframe with /embed/swipe
 * Mobile: renders navigation button to /plan?tab=swipe
 */
interface SwipeEmbedParams {
  embedUrl: string;
  fallbackUrl: string;
  height: number;
  title?: string;
}

function SwipeEmbedResource(props: { params?: SwipeEmbedParams }) {
  const embedUrl = () => props.params?.embedUrl || '/embed/swipe';
  const fallbackUrl = () => props.params?.fallbackUrl || '/plan?tab=swipe';
  const height = () => props.params?.height || 450;

  // Viewport detection with reactive signal
  const [isDesktop, setIsDesktop] = createSignal(
    typeof window !== 'undefined' ? window.innerWidth > 768 : true
  );

  // Loading and error state for iframe
  const [iframeLoaded, setIframeLoaded] = createSignal(false);
  const [iframeError, setIframeError] = createSignal(false);

  // Handle viewport resize
  if (typeof window !== 'undefined') {
    const handleResize = () => {
      setIsDesktop(window.innerWidth > 768);
    };

    // Use onMount equivalent pattern for event listener
    window.addEventListener('resize', handleResize);
    // Note: In a full implementation, cleanup would be in onCleanup
  }

  // Handle iframe load
  const handleIframeLoad = () => {
    setIframeLoaded(true);
  };

  // Handle iframe error - show fallback button
  const handleIframeError = () => {
    setIframeError(true);
  };

  // If iframe failed, show fallback button regardless of viewport
  const showButton = () => !isDesktop() || iframeError();

  return (
    <div class="swipe-embed-resource">
      <Show
        when={!showButton()}
        fallback={
          <a
            href={fallbackUrl()}
            class="inline-flex items-center gap-2 px-4 py-2.5 bg-primary text-primary-foreground rounded-lg hover:bg-primary/90 transition-colors font-medium text-sm"
          >
            Swipe to plan ! →
          </a>
        }
      >
        {/* Desktop: iframe */}
        <div
          class="relative w-full rounded-lg overflow-hidden"
          style={{ height: `${height()}px` }}
        >
          {/* Loading spinner while iframe loads */}
          <Show when={!iframeLoaded()}>
            <div class="absolute inset-0 flex items-center justify-center bg-muted/50">
              <div class="animate-spin w-6 h-6 border-2 border-primary border-t-transparent rounded-full" />
            </div>
          </Show>
          <iframe
            src={embedUrl()}
            class="w-full h-full border-0"
            classList={{ 'opacity-0': !iframeLoaded(), 'opacity-100': iframeLoaded() }}
            style={{ transition: 'opacity 0.2s ease-in-out' }}
            onLoad={handleIframeLoad}
            onError={handleIframeError}
            title="Swipe Strategies"
          />
        </div>
      </Show>
    </div>
  );
}
```

3. **Add onMount and onCleanup imports** at line 14 (modify existing import):
Change:
```tsx
import { Show, createSignal, createMemo, For, Switch, Match } from 'solid-js';
```
To:
```tsx
import { Show, createSignal, createMemo, For, Switch, Match, onMount, onCleanup } from 'solid-js';
```

4. **Refactor resize listener** to use onMount/onCleanup for proper cleanup:
```tsx
// Inside SwipeEmbedResource, replace the if(typeof window) block with:
onMount(() => {
  if (typeof window === 'undefined') return;

  const handleResize = () => {
    setIsDesktop(window.innerWidth > 768);
  };

  window.addEventListener('resize', handleResize);

  onCleanup(() => {
    window.removeEventListener('resize', handleResize);
  });
});
```

Key implementation decisions from CONTEXT.md:
- Full width, 450px height (from UIResource config)
- Minimal styling: rounded corners only (rounded-lg), no shadows, no border
- Button text: "Swipe to plan ! →" (exact text)
- Error fallback: show button if iframe fails
- Loading: spinner while iframe loads
  </action>
  <verify>
1. Run `pnpm typecheck` from monorepo root - must pass
2. Run `pnpm dev` and trigger swipe intent in chat (type "swipe")
3. On desktop (>768px viewport): iframe should appear with /embed/swipe content
4. On mobile (<768px viewport or resize): button should appear
5. Click button navigates to /plan?tab=swipe
  </verify>
  <done>
- MCPUIRenderer handles swipe_embed type
- Desktop shows iframe with SwipeTab
- Mobile shows navigation button
- Viewport resize switches rendering mode
- TypeScript compiles without errors
  </done>
</task>

</tasks>

<verification>
After task completion:

1. **TypeScript:** `pnpm typecheck` passes
2. **Desktop rendering:** Type "swipe" in chat, see iframe with Swipe cards (viewport >768px)
3. **Mobile rendering:** Resize to <768px or use dev tools mobile view, see "Swipe to plan ! →" button
4. **Resize behavior:** Resize viewport across 768px threshold, observe switch between iframe/button
5. **Button navigation:** Click button, navigate to /plan?tab=swipe
6. **Iframe loads:** Iframe shows SwipeTab content (same as visiting /embed/swipe directly)
7. **Error fallback:** If iframe fails (simulate by changing embedUrl), button appears instead
</verification>

<success_criteria>
- RESP-01: Desktop renders iframe ✓
- RESP-02: Mobile renders button ✓
- RESP-03: Viewport changes update rendering ✓
- Error fallback works (bonus from CONTEXT.md)
</success_criteria>

<output>
After completion, create `.planning/phases/04-responsive-rendering/04-01-SUMMARY.md`
</output>
